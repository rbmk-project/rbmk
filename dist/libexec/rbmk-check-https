#!/usr/bin/env python3

# SPDX-License-Identifier: GPL-3.0-or-later

import datetime
import getopt
import ipaddress
import pathlib
import subprocess
import sys
from typing import Iterator, List


def usage(filep):
    """Prints the usage message."""
    print(
        """
usage: rbmk check-https [flags...]

Check HTTPS availability for a list of domains.

For each domain, we:

1. Resolve A and AAAA records.

2. Attempt HTTPS connections to each resolved IP addrs.

3. Save DNS queries and HTTPS attempts logs.

We currently support the following command line flags:

    -h, --help
        Print this help message.

    -i, --input DOMAIN
        Check the given DOMAIN. Specify this flag multiple times
        to check multiple domains. You can safely combine this flag
        with `-f` to specify domains inline and read them from file.

    -f, --input-file FILE
        Read domains from FILE. Specify this flag multiple times
        to read from multiple files. Each file line must either be
        a domain or a comment (starting with `#`). You can safely
        combine this flag with `-i` to specify extra domains inline.

If no domain is specified either using `-i` or `-f`, this
command does nothing and exits immediately.

Results are saved in:

    var/rbmk/check-https/YYYYMMDDTHHMMSSZ/
""",
        file=filep,
    )


def _make_ipaddr_fs_safe(ip: str) -> str:
    """
    Makes an IP address filesystem-safe.
    """
    return ip.replace(":", "-").replace(".", "-")


def _is_ip_address(s: str) -> bool:
    """
    Returns True if the given string is a valid IP address.
    """
    try:
        ipaddress.ip_address(s)
        return True
    except ValueError:
        return False


def _read_domains(fname: str) -> Iterator[str]:
    """
    Reads the domains to check from the given file.
    """
    with open(fname) as f:
        for line in f:
            line = line.strip()
            if line and not line.startswith("#"):
                yield line


class _MeasureDomain:
    """Measures a given domain."""

    def __init__(self, rbmk: pathlib.Path, outdir: pathlib.Path, domain: str):
        self._domaindir = outdir / domain
        self._domaindir.mkdir(parents=True, exist_ok=True)
        self._domain = domain
        self._method = "HEAD"
        self._rbmk = rbmk

    def _rbmk_dig(self, qtype: str) -> str:
        """
        Resolve DNS records of the given qtype using `rbmk dig`.
        """
        print(f"  Resolving DNS {qtype} records...")
        out = self._domaindir / f"dig_{qtype.lower()}"

        # Use `rbmk dig` to resolve DNS records
        result = subprocess.run(
            [
                self._rbmk,
                "dig",
                "+short",
                "--logs",
                f"{out}.jsonl",
                qtype,
                self._domain,
            ],
            stdout=subprocess.PIPE,
            text=True,
        )

        # Filter only IP addresses from the output
        ips = [ip for ip in result.stdout.splitlines() if _is_ip_address(ip)]
        with open(f"{out}.txt", "w") as filep:
            for ip in ips:
                filep.write(f"{ip}\n")
        return f"{out}.txt"

    def _lookup_host(self) -> List[str]:
        """
        Resolve DNS records using both A and AAAA queries.
        """

        if _is_ip_address(self._domain):
            return [self._domain]

        # Resolve using both A and AAAA queries
        files: List[str] = []
        for qtype in ["A", "AAAA"]:
            files.append(self._rbmk_dig(qtype))

        # Combine unique IPs
        all_ips = set()
        for filename in files:
            try:
                with open(filename) as filep:
                    all_ips.update(line.strip() for line in filep)
            except FileNotFoundError:
                continue
        return sorted(all_ips)

    def _rbmk_curl(self, ip: str):
        """
        Measures a given HTTPS endpoint using `rbmk curl`.
        """
        safe_ip = _make_ipaddr_fs_safe(ip)
        print(f"  Accessing https://{self._domain}/ via {ip}...")
        curl_base = self._domaindir / f"curl_{safe_ip}"
        with open(f"{curl_base}.body", "w") as body:
            with open(f"{curl_base}.stderr", "w") as stderr:
                subprocess.run(
                    [
                        self._rbmk,
                        "curl",
                        "--max-time",
                        "5",
                        "-X",
                        self._method,
                        "--logs",
                        f"{curl_base}.jsonl",
                        "--resolve",
                        f"{self._domain}:443:{ip}",
                        f"https://{self._domain}/",
                    ],
                    stdout=body,
                    stderr=stderr,
                )

    def run(self):
        """
        Run the measurement.
        """
        print("")
        print(f"Measuring input {self._domain}...")

        with open(self._domaindir / "input.txt", "w") as filep:
            filep.write(f"{self._domain}\n")

        for ip in self._lookup_host():
            self._rbmk_curl(ip)


class _Command:
    """
    Command line interface for `rbmk check-https`.
    """

    def __init__(self):
        scriptdir = pathlib.Path(__file__).parent.resolve()
        scriptdir = scriptdir.relative_to(pathlib.Path.cwd())
        self._rbmk = scriptdir / "rbmk.real"
        timestamp = datetime.datetime.now(datetime.UTC).strftime("%Y%m%dT%H%M%SZ")
        self._outdir = scriptdir.parent / "var" / "rbmk" / "check-https" / timestamp
        self._outdir.mkdir(parents=True, exist_ok=True)

    def run(self, inputs: List[str], input_files: List[str]):
        """
        Run the command.
        """
        print("")
        print(f"Using output directory: {self._outdir}")

        for domain in inputs:
            _MeasureDomain(self._rbmk, self._outdir, domain).run()

        for input_file in input_files:
            print(f"Reading domains from: {input_file}")
            for domain in _read_domains(input_file):
                _MeasureDomain(self._rbmk, self._outdir, domain).run()

        print("")
        print(f"Done! Results in: {self._outdir}")
        print("")


def main():
    """Main function."""
    cmd = _Command()

    # TODO(bassosimone): allow to specify the resolver you want
    # to use from the command line.

    try:
        opts, args = getopt.getopt(
            sys.argv[1:],
            "hf:i:",
            ["help", "input=", "input-file="],
        )
    except getopt.GetoptError as err:
        print(f"rbmk check-https: {err}", file=sys.stderr)
        usage(filep=sys.stderr)
        sys.exit(1)

    if args:
        if args[0] == "help":
            usage(filep=sys.stdout)
            sys.exit(0)
        print("rbmk check-https: unexpected arguments", file=sys.stderr)
        usage(filep=sys.stderr)
        sys.exit(1)

    inputs: List[str] = []
    input_files: List[str] = []
    for key, value in opts:
        if key in ("-h", "--help"):
            usage(filep=sys.stdout)
            sys.exit(0)
        elif key in ("-f", "--input-file"):
            input_files.append(value)
        elif key in ("-i", "--input"):
            inputs.append(value)

    cmd.run(inputs, input_files)


if __name__ == "__main__":
    main()
