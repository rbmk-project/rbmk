// SPDX-License-Identifier: GPL-3.0-or-later

package qa

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"io"

	"github.com/rbmk-project/rbmk/pkg/cli"
	"github.com/rbmk-project/rbmk/pkg/cli/internal/testable"
	"github.com/rbmk-project/rbmk/pkg/x/netsim"
	"github.com/rbmk-project/rbmk/pkg/x/netsim/geolink"
	"github.com/stretchr/testify/require"
)

// ScenarioEditor modifies a [*netsim.Scenario]. Editors are the building
// blocks used to create complex censorship scenarios. They are composable:
// you can combine multiple editors to create sophisticated test cases.
type ScenarioEditor func(scenario *netsim.Scenario) *netsim.Scenario

// MustNewCommonScenario creates a new netsim.Scenario with frequently
// used hosts (dns.google, www.example.com) already configured. It
// panics on any initialization error.
//
// The cacheDir parameter specifies where to cache TLS certificates.
func MustNewCommonScenario(cacheDir string) *netsim.Scenario {
	scenario := netsim.NewScenario(cacheDir)
	scenario.Attach(scenario.MustNewGoogleDNSStack())
	scenario.Attach(scenario.MustNewExampleComStack())
	return scenario
}

// ScenarioDescriptor describes a complete test scenario, including the
// network conditions to simulate (via Editors), the command to run (via
// Argv), and the expected outcome (via ExpectedErr).
type ScenarioDescriptor struct {
	// Name identifies this scenario for logging and debugging.
	Name string

	// Editors modify the network environment for this scenario.
	Editors []ScenarioEditor

	// Argv contains the command line arguments to execute.
	Argv []string

	// ExpectedErr is the error we expect from running
	// the command. If nil, we expect the command to succeed.
	ExpectedErr error

	// ExpectedSeq contains the sequence of events that we
	// expect in the resulting structured logs.
	ExpectedSeq []ExpectedEvent
}

// Run runs the given [*ScenarioDescriptor] using the given [Driver] and
// sets the failure state accordingly using the [Driver] interface, which
// can be implemented using, e.g., [*testing.T].
//
// This method returns an [io.Reader] from which the caller can read the
// structured logs generated by running this command.
func (desc *ScenarioDescriptor) Run(t Driver) io.Reader {
	// Initialize the scenario and apply all the editors.
	scenario := MustNewCommonScenario("testdata")
	defer scenario.Close()
	for _, modifier := range desc.Editors {
		scenario = modifier(scenario)
	}

	// Obtain the client stack and override the function used
	// to dial new network connections, to use the simulated stack
	// rather than using the host's network stack.
	stack := scenario.MustNewClientStack()
	linkConfig := &geolink.Config{
		Delay: 0, // TODO(bassosimone): set delay? make configurable?
		Log:   true,
	}
	scenario.Attach(geolink.Extend(stack, linkConfig))
	testable.DialContext.Set(stack.DialContext)
	testable.RootCAs.Set(scenario.RootCAs())

	// Override the specific stdout used to generate structured logs.
	//
	// We use io.Pipe() here because:
	//
	// 1. It provides thread-safe writing through the pipe
	//
	// 2. It ensures we can safely collect all logs before reading them
	//
	// 3. It guarantees proper synchronization between writers and reader
	//
	// Note that `nil` restores `os.Stdout` as the default.
	rpipe, wpipe := io.Pipe()
	env := testable.NewEnvironment()
	env.SetStdout(wpipe)
	defer wpipe.Close()

	// Buffer to collect all logs and channel to
	// signal when collection is complete
	var stdoutBuffer bytes.Buffer
	copyDone := make(chan struct{})
	go func() {
		io.Copy(&stdoutBuffer, rpipe)
		close(copyDone)
	}()

	// Create the main RBMK command.
	cmd := cli.NewCommand()

	// Execute the given argv.
	err := cmd.Main(context.Background(), env, desc.Argv...)

	// Check whether the return value is OK.
	if desc.ExpectedErr != nil {
		require.EqualError(t, err, desc.ExpectedErr.Error(),
			"scenario %s should return expected error", desc.Name)
	} else {
		require.NoError(t, err, "scenario %s should not return error", desc.Name)
	}

	// Ensure we've collected all logs before returning the reader.
	//
	// 1. Close the write end of the pipe
	//
	// 2. Wait for the copying goroutine to finish
	//
	// 3. Return the logs buffer
	wpipe.Close()
	<-copyDone
	return &stdoutBuffer
}

// VerifyEvents checks that the emitted events match expectations.
//
// The matching algorithm handles both exact matches and sequences
// of non-deterministic events (e.g., reads/writes) that may appear
// zero or more times in the actual event stream.
func (desc *ScenarioDescriptor) VerifyEvents(t Driver, r io.Reader) {
	// Implementation note: the algorithm uses two pointers:
	//
	// - i: points to current expected event/pattern
	//
	// - j: points to current actual event
	//
	// For each iteration, we either:
	//
	// 1. Consume an actual event that matches a pattern (j++)
	//
	// 2. Skip a pattern that doesn't match current event (i++)
	//
	// 3. Compare exact events and advance both (i++, j++)
	//
	// This allows us to verify the core measurement sequence while
	// being flexible about the number and timing of I/O operations.

	// Build the list of events to verify
	var evs []*Event
	sx := bufio.NewScanner(r)
	for sx.Scan() {
		var got Event
		err := json.Unmarshal(sx.Bytes(), &got)
		require.NoError(t, err, "failed to parse event")
		evs = append(evs, &got)
	}
	require.NoError(t, sx.Err(), "failed to scan events")

	// Loop until we have events or expectations to compare
	for i, j := 0, 0; i < len(desc.ExpectedSeq) && j < len(evs); {
		// Obtain the current expectation and event to compare
		expect := &desc.ExpectedSeq[i]
		got := evs[j]

		switch {
		// Case 1: consume event that matches the pattern
		case expect.Pattern&MatchAnyRead != 0 && got.Msg == "readStart":
			fallthrough
		case expect.Pattern&MatchAnyRead != 0 && got.Msg == "readDone":
			fallthrough
		case expect.Pattern&MatchAnyWrite != 0 && got.Msg == "writeStart":
			fallthrough
		case expect.Pattern&MatchAnyWrite != 0 && got.Msg == "writeDone":
			fallthrough
		case expect.Pattern&MatchAnyClose != 0 && got.Msg == "closeStart":
			fallthrough
		// TODO(bassosimone): need to add support for setting the deadline here
		case expect.Pattern&MatchAnyClose != 0 && got.Msg == "closeDone":
			t.Logf("skipping at j=%d: %+v", j, got)
			got.VerifyReadWriteClose(t)
			j++
			continue

		// Case 2: skip pattern that does not match current event
		case expect.Pattern != 0:
			i++
			continue

		// Case 3: compare exact events and advance both
		default:
			i, j = i+1, j+1
			t.Logf("comparing at i=%d, j=%d: %+v to %+v", i, j, expect, got)
			expect.VerifyEqual(t, got)
		}
	}
}
