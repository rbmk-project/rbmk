//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// Code to generate shell scripts.
//

package generate

import (
	"fmt"
	"io"
	"strings"
	"time"

	"github.com/rbmk-project/common/runtimex"
)

// shGenerator generates a shell script.
//
// The zero value IS NOT ready to use and you must explicitly
// call [newGenerator] to obtain a ready-to-use shGenerator.
type shGenerator struct {
	// writer is the writer to which we write the shell script.
	writer io.Writer
}

// newShGenerator creates a new [*generator] using the given [io.Writer].
func newShGenerator(w io.Writer) *shGenerator {
	return &shGenerator{writer: w}
}

// CompressResultsDir generates the code to compress the results
// directory into a tarball and remove the original directory.
func (g *shGenerator) CompressResultsDir() {
	fmt.Fprintf(g.writer, "# Compress the results directory\n")
	fmt.Fprintf(g.writer, "rbmk tar -czf \"$RESULTSDIR.tar.gz\" \"$RESULTSDIR\"\n")
	fmt.Fprintf(g.writer, "rbmk rm -rf \"$RESULTSDIR\"\n")
	fmt.Fprintf(g.writer, "echo \"Written results at $RESULTSDIR.tar.gz\"\n")
	fmt.Fprintf(g.writer, "\n")
}

// MakeResultsDir generates the code to make the results directory.
func (g *shGenerator) MakeResultsDir(name string) {
	fmt.Fprintf(g.writer, "# Make the results directory\n")
	fmt.Fprintf(g.writer, "RESULTSDIR=\"$(rbmk timestamp)-%s\"\n", name)
	fmt.Fprintf(g.writer, "rbmk mkdir -p \"$RESULTSDIR\"\n")
	fmt.Fprintf(g.writer, "\n")
}

// ProgressBarDone generates the code to finish the progress bar.
func (g *shGenerator) ProgressBarDone(name string, total int) {
	fmt.Fprintf(g.writer, "# Update the progress bar\n")
	fmt.Fprintf(
		g.writer,
		"printf \"%%s\\n\" \"%s [====================] 100%% (%d/%d)\"\n",
		name,
		total,
		total,
	)
	fmt.Fprintf(g.writer, "\n")
}

// ScriptPrefix generates the shell script prefix.
func (g *shGenerator) ScriptPrefix() {
	fmt.Fprintf(g.writer, "#!/bin/bash\n")
	fmt.Fprintf(g.writer, "\n")

	fmt.Fprintf(
		g.writer,
		"# Generated by `rbmk generate` on %s\n",
		time.Now().UTC().Format("20060102T150405Z"),
	)
	fmt.Fprintf(g.writer, "\n")

	fmt.Fprintf(g.writer, "# Ensure that usage errors terminate the script, that\n")
	fmt.Fprintf(g.writer, "# undefined variables cause errors, and that any command\n")
	fmt.Fprintf(g.writer, "# that fails in a pipeline causes an error.\n")
	fmt.Fprintf(g.writer, "set -euo pipefail\n")
	fmt.Fprintf(g.writer, "\n")
}

// UpdateProgressBar generates the code to update the progress bar.
func (g *shGenerator) UpdateProgressBar(name string, idx, total int) {
	runtimex.Assert(total > 0, "total must be a positive value")
	fmt.Fprintf(g.writer, "# Update the progress bar\n")
	progress := (20 * idx) / total
	var bar strings.Builder
	bar.WriteRune('[')
	for pos := 0; pos < 20; pos++ {
		if pos < progress {
			bar.WriteRune('=')
		} else {
			bar.WriteRune('-')
		}
	}
	bar.WriteRune(']')
	fmt.Fprintf(
		g.writer,
		"printf \"%%s\\r\" \"%s %s %d%% (%d/%d)\"\n",
		name,
		bar.String(),
		progress*5, // convert from 1/20 to 1/100
		idx,
		total,
	)
	fmt.Fprintf(g.writer, "if [[ \"${RBMK_TRACE:-0}\" == \"1\" ]]; then\n")
	fmt.Fprintf(g.writer, "\tprintf \"\\n\"\n")
	fmt.Fprintf(g.writer, "fi\n")
	fmt.Fprintf(g.writer, "\n")
}

// WriteHelpInterceptor writes the code to intercept the `-h, --help` option.
func (g *shGenerator) WriteHelpInterceptor(helpFuncName string) {
	fmt.Fprintf(g.writer, "# Intercept the `-h, --help` option\n")
	fmt.Fprintf(g.writer, "for arg in \"$@\"; do\n")
	fmt.Fprintf(g.writer, "\tcase \"$arg\" in\n")
	fmt.Fprintf(g.writer, "\t-h|--help)\n")
	fmt.Fprintf(g.writer, "\t\t%s\n", helpFuncName)
	fmt.Fprintf(g.writer, "\t\texit 0\n")
	fmt.Fprintf(g.writer, "\t\t;;\n")
	fmt.Fprintf(g.writer, "\tesac\n")
	fmt.Fprintf(g.writer, "done\n")
	fmt.Fprintf(g.writer, "\n")
}

// WriteTraceInterceptor writes the code to intercept the `-v, --verbose` option.
func (g *shGenerator) WriteTraceInterceptor() {
	fmt.Fprintf(g.writer, "# Intercept the `-v, --verbose` option\n")
	fmt.Fprintf(g.writer, "for arg in \"$@\"; do\n")
	fmt.Fprintf(g.writer, "\tcase \"$arg\" in\n")
	fmt.Fprintf(g.writer, "\t-v|--verbose)\n")
	fmt.Fprintf(g.writer, "\t\texport RBMK_TRACE=\"1\"\n")
	fmt.Fprintf(g.writer, "\t\t;;\n")
	fmt.Fprintf(g.writer, "\tesac\n")
	fmt.Fprintf(g.writer, "done\n")
	fmt.Fprintf(g.writer, "\n")
}

// Writer returns the writer used by the generator.
func (g *shGenerator) Writer() io.Writer {
	return g.writer
}
